# 常考部分知识点
## 1. 如何理解 js 中的 this 关键字？

this 表示当前对象，this 的指向是根据调用的上下文来决定的，默认指 Window 对象。

**全局环境**：全局环境就是在里面，这里的 this 始终指向的事 window 对象。

**局部环境：** 

    1.在全局作用域下直接调用函数，this 指向 window 
    2.对象函数调用，哪个对象调用就指向哪个对象 
    3.使用 new 实例化对象，在构造函数中的 this 指向实例化对象   
    4.使用 call 或 apply 改变 this 的指向

## 2. JavaScript 中的作用域（scope）是指什么？

在 Javascript 中，每个函数都有自己的作用域。作用域基本上是变量以及 如何通过名称访问这些变量的规则集合。只有函数中的代买才能访问函数作用域内的变量。
同一个作用域中的变量名称是唯一的。一个作用域可以嵌套在另一个作用域内。如果一个作用域嵌套在另一个作用域内，最内部作用域内的代码可以访问另一个作用域的变量。

## 3. 什么是闭包？

闭包是在另一个作用域内创建一个封闭的词法范围。它通常会自动返回来生成这个词法环境。这个环境由创建闭包时在作用域内的任何局部变量组成。它就像一个微型工厂，用这些原料生产出具有特定功能的产品。

## 4. 解释 JavaScript 中的相等性？

**JavaScript 中有严格比较和类型转换比较：**

​ 严格比较（例如 ===）在不允许强制转型的情况下检查两个值是否相等；
​ 抽象比较（例如 ==）在允许强制转型的情况下检查两个值是否相等。
​ 如果被比较的任何一个值可能是 true 或 false，要用 ===，而不是 ==；
​ 如果被比较的任何一个值是这些特定值（0、“”或 []），要用 ===，而不是 ==；
​ 在其他情况下，可以安全地使用 ==。它不仅安全，而且在很多情况下，它可以简化代码，并且提升代码可读性。

## 5. 解释一下变量的提升？

变量的提升是 JavaScript 的默认行为，这意味着将所有变量声明移动到当前作用域的顶部，并且可以在声明之前使用变量。初始化不会被提升，提升仅作用于变量的声明。

```js
var x = 1;
console.log(x + "——" + y); // 1——undefined
var y = 2;
```

## 6. 如何理解事件委托?

在 DOM 树上绑定事件监听器并使用 JS 事件处理程序是处理客户端事件响应的典型方法。 从理论上讲，我们可以将监听器附加到 HTML 中的任何 DOM 元素，但由于事件委派，这样做是浪费而且没必要的。

**什么是事件委托：**
这是一种让父元素上的事件监听器也影响子元素的技巧。 通常，事件传播（捕获和冒泡）允许我们实现事件委托。 冒泡意味着当触发子元素（目标）时，也可以逐层触发该子元素的父元素，直到它碰到 DOM 绑定的原始监听器（当前目标）。 捕获属性将事件阶段转换为捕获阶段，让事件下移到元素; 因此，触发方向与冒泡阶段相反。 捕获的默认值为 false。

## 7. 解释一下严格模式(strict mode)?

严格模式用于标准化正常的 JavaScript 语义。严格模式可以嵌入到非严格模式中，关键字 ‘use strict’。使用严格模式后的代码应遵循 JS 严格的语法规则。例如，分号在每个语句声明之后使用。

## 8. 解释 JavaScript 中的 null 和 undefined?

- JavaScript 中有两种底层类型：null 和 undefined。它们代表了不同的含义：
- 尚未初始化：undefined；
- 空值：null

```js
//null和undefined是两个不同的对象
null == null; //true
null === null; //true
null == undefined; //true
null === undefined; //flase
```

## 9. 解释 JavaScript 中的值和类型?

```js
JavaScript提供两种数据类型: 基本数据类型和引用数据类型。
区别是：存储的位置不同
    基本数据类型：直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。
    引用数据类型：存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在
    栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实
    体。
(栈)基本数据类型有:
    String
    Number
    Boolean
    Null
    Undefined
    Symbol
(堆)引用数据类型有:
    Object
    Array
    Function
```

## 10. 解释事件冒泡以及如何阻止它？

事件冒泡是指嵌套最深的元素触发一个事件，然后这个事件顺着嵌套顺序在父元素上触发。

防止事件冒泡的一种方法是使用 event.stopPropagation()或 event.cancelBubble （低于 IE 9）。

## 11. window.onload 的作用？

window.onload 是等文档和资源都加载完成后调用的事件，保证 js 获取元素 的时候，已经加载。

## 12. 说说你对作用域链的理解？

**作用域链是js中的一种查找机制，** 
从当前作用域查找，当前作用域没有往上一级作用域查找，一直到最外层，如果都找不到则是is not define。
  作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。

  作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前
  端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

  当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。
  作用域链的创建过程跟执行上下文的建立有关....

## 13. 定时器的分类？他们的区别及用法是什么？

```js
Js中有两种定时器：setInterval：间歇执行，setTimeout：延迟执行
setInterval(函数，时间) 时间单位ms，
语法：setInterval(function(){},1000); 隔一秒执行函数一次
一般用于倒计时，轮播图
setTimeout(函数，时间) 时间单位ms，
语法：setTimeout(function(){},1000); 延迟一秒执行函数一次，只会执行一次
一般用于广告，广告弹出层
```

## 14. 把下面的字符串去重，并去除掉特殊字符按照数字在前字母在后的顺序排序字符串?

```js
//如下：“1233fddfd&3434fdsaff&454545&4545444rfdsfds&545gdsgs”
var str = “1233fddfd&3434fdsaff&454545&4545444rfdsfds&545gdsgs”;
var n = “”;
var s="";
for(var i=0;i<str.length;i++){
    if((str[i]>=0&&str[i]<=9)&&n.indexOf(str[i])==-1){
        n+=str[i];
    }else if((str.charCodeAt(i)>=97&&str.charCodeAt(i)<=122)&&s.indexOf(str[i]) == -1){
        s+=str[i];
    }
}
console.log(n+s); //12345fdsarg
```

## 15. 截取字符串“abcdefg”中的 def?

```js
var str = “abcdefg”;
if(str.indexOf(“def”)!=-1){
    console.log(str.substr(str.indexOf(“def”),3));
}
```

## 16. 数组方法 pop() push() unshift() shift()？

  push:在数组末尾添加一个或多个元素 Pop:在数组末尾删除一个元素，返回被删除的元素
  unshift：在数组的头部添加或删除元素 shift：在数组头部删除一个元素，返回被删除的元素

## 17. split() join() 的区别？

  split是字符串的方法，将字符串按照特定标志分割成数组

      例：“u&s”.split(“&”) ------ [“u”,”s”]

  Join:是数组方法，将数组按标志组合成字符串 [“u”,”s”].join（“-”）–‘u-s’

## 18. 编写一个数组去重的方法?

```js
function sort(arr) {
    for(var i = 0;i<arr.length;i++){
        for(var j = i+1;j<arr.length;j++){
            if(arr[i] == arr[j]){
                arr.splice(j,1);
                j–; //删除一个元素后，后面的元素会依次往前，下标也需要依次往前
            }
        }
    }
    return arr
}
```

## 19. 冒泡算法排序？

```js
for (var i = 0; i < arr.length; i++) {
  for (var j = 0; j < arr.length - i; j++) {
    if (arr[j] > arr[j + 1]) {
      //
      var temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
    }
  }
}
```

## 20. DOM 怎样添加、移除、移动、复制、创建和查找节点?

```js
//创建新节点
    createDocumentFragment(node);
    createElement(node);
    createTextNode(text);
//添加、移除、替换、插入
    appendChild(node)
    removeChild(node)
    replaceChild(new,old)
    insertBefore(new,old)
//查找
    getElementById();
    getElementsByName();
    getElementsByTagName();
    getElementsByClassName();
    querySelector();
    querySelectorAll();
//属性操作
    getAttribute(key);
    setAttribute(key, value);
    hasAttribute(key);
    removeAttribute(key);
```

## 21. 什么是 window 对象? 什么是 document 对象?

    window是js中最大的对象，表示窗口，包含document
    document文档对象，表示HTML

## 22. offsetWidth、clientWidth、scrollTop 的区别？

    offsetWidth：占位宽，包含 内容宽+左右padding+左右border
    clientWidth：可视宽，包含 内容宽+左右padding
    scrollTop：页面被卷去的高

## 23. 如何获取 url 地址中搜索内容？

    window.location.search

## 24. 事件绑定和普通事件有什么区别?

    标签.事件：如果给同一个元素添加同一个事件，后面的会覆盖前面
    事件绑定：可以给同一个元素添加同一个事件，不会被覆盖

## 25. 解释一下事件流？

    事件捕获阶段：当事件发生的时候，将事件从window依次往子元素传递
    确定目标阶段：确定事件目标
    事件冒泡阶段：事件目标开始处理事件，处理完以后会将事件依次传递给父元素，一直到window
    事件都是在事件冒泡处理,ie只有冒泡

## 26. 拖拽效果中有几种事件？

    按下onmousedown，拖拽onmousemove，弹起onmouseup

## 27. cookie 的利弊？

    优点：极高的扩展性和可用性
        1.通过良好的编程，控制保存在cookie中的session对象的大小。
        2.通过加密和安全传输技术（SSL），减少cookie被破的可能性。
        3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
        4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
        1.Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超
        过4KB，否则会被截掉。
        2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
        与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
        的了。
        3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
        一个计数器。
        如果我们把这个计数器保存在客户端，那么它起不到任何作用。
        因为这些弊端（主要是cookie的大小和多少都受限制，并且每次你请求一个新的页面的时候
        Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨
        域调用），IE8以后，就出现一个web storage；它仅仅是为了本地缓存数据而存在；但是
        Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而
        存在。

## 28. call()和 apply()的区别和作用？

    都是用来改变this的指向，在传值的过程中会有些区别：
    call（this的指向，参数1，参数2…）
        call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this
        指向，从第二个参数开始往后，每个参数被依次传入函数。
    apply（this的指向,[参数1，参数2…]）
        apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带
        下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为
        参数传递给被调用的函数。

call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。

## 29. 创建 ajax 的过程?

    1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象
    2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息
    3.设置响应 HTTP 请求状态变化的函数
    4.发送 HTTP 请求
    5.获取异步调用返回的数据
    6.使用 JavaScript 和 DOM 实现局部刷新

```js
function ajax(json) {
    json.data = json.data||""; //如果没有请求参数，为空
    json.contentType = json.contentType || “application/x-www-form-urlencoded”; //如果没有字符编码，用默认的
    //1.创建对象
    if(window.XMLHttpRequest){ //正常
        var ajax = new XMLHttpRequest();
    }else { //兼容ie6
        var ajax = new ActiveXObject(“Microsoft.XMLHTTP”);
    }
    //2.建立连接
    if(json.type.toUpperCase() ==“get”.toUpperCase()){
           ajax.open(“GET”,json.url+"?"+json.data,true);
        //3.发送请求
        ajax.send();
        }else {
               ajax.open(“POST”,json.url,true);
             //3.设置请求头 ajax.setRequestHeader(“Content-type”,json.contentType+";charset=utf-8");
             //4.发送请求
               ajax.send(json.data);
             }
     //4.监听结果
     ajax.onreadystatechange = function () {
           if(ajax.readyState == 4){
                   if(ajax.status == 200){
                           json.success(ajax.response);
                       }
               }
         }
}
```

## 30. ajax 请求的时候 get 和 post 方式的区别，什么时候用 post?

    GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给WEB服务
    器。当然在Ajax请求中，这种区别对用户是不可见的
    GEt传输数据容量小，不安全，post传输数据内容大，更加安全；
    当向服务器发送一些数据的时候选择post比较安全

## 31. ajax 请求时，如何解释 json 数据?

    如果是字符串形式的json：eval("("+ajax.response+")")
    如果是本地的json文件：JSON.parse(data)

## 32. 同步和异步的区别?

    异步：客户端与服务器请求数据的过程中，可以做其他的事情
    同步：客户端与服务器请求数据的过程中，不能做其他的事情

## 33. js 哪些操作会造成内存泄露？

    意外的全局变量引起的内存泄露
    function leak(){ leak=“xxx”;//leak成为一个全局变量，不会被回收 }
    被遗忘的定时器或者回调
    闭包引起的内存泄漏

## 34. $(document).ready() 方法和 window.onload 有什么区别？

    window.onload与ready的区别
        1.window.onload会覆盖之前的
        ready的区别，不会覆盖，会叠加
        2.window.onload等文档和资源都加载完成以后调用
        ready只要文档加载完成以后就会调用

## 35. || 和 && 操作符的返回值？

```js
|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。
对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。
&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。
|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果
```

## 36. 事件委托是什么？

    事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且
    父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父
    节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

    使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。
    并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要
    单独地为它添加一个监听事件，
    它所发生的事件会交给父元素中的监听函数来处理。

## 37. 什么是闭包，为什么要用它？

    闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内
    创建另一个函数，创建的函数可以访问到当前函数的局部变量。

    闭包有两个常用的用途：
        闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可
        以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建
        私有变量。

        函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包
        函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的
实现原理。

## 38. 什么是浏览器的同源策略？

    一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个
    域的协议、域名、端口号必须相同，否则则不属于同一个域。

    同源政策主要限制了三个方面：
        第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
        第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
        第三个是当前域下 ajax 无法发送跨域请求。

    同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器
    的限制，
    对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应
    结果来进行可能出现安全问题的操作。

## 39. 如何解决跨域问题？

    使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为
    浏览器对script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后
    服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，
    前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可
    以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。
    使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。CORS 需要浏览器和服务器
    同时支持。
    目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成
    两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在
    头信息之中，增加一个Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个
    值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正
    常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字
    段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 
    Access-Control- 开头的字段。

    使用 websocket 协议，这个协议没有同源限制。
    使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，
    然后最后将获取的结果发返回。

## 40. 数组和对象有哪些原生方法，列举一下？

    数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指
    定转换为字符串时的分隔符。

    数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。

    数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 
    方法可以传
    入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。

    数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。

    数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。

    数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf()
    迭代方法
    every()、some()、filter()、map() 和 forEach() 方法

    数组归并方法 reduce() 和 reduceRight() 方法

## 41. JavaScript 中的作用域与变量声明提升？

    变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们
    可以在变量声明前访问到而不会报错。

    造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初
    始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作
    用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上
    下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候
    创建的。这就是会出现变量声明提升的根本原因。
